__BRYTHON__.VFS_timestamp = 1757068233225
if(typeof document !== 'undefined'){
    __BRYTHON__.brython_modules = $B.last(document.getElementsByTagName('script')).src
}
__BRYTHON__.use_VFS = true
var scripts = {"$timestamp": 1757068233225, "browser.local_storage": [".py", "\nimport sys\nfrom browser import window,console\n\nhas_local_storage=hasattr(window,'localStorage')\n\nclass _UnProvided():\n pass\n \nclass LocalStorage():\n storage_type=\"local_storage\"\n \n def __init__(self):\n  if not has_local_storage:\n   raise EnvironmentError(\"LocalStorage not available\")\n  self.store=window.localStorage\n  \n def __delitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if key not in self:\n   raise KeyError(key)\n  self.store.removeItem(key)\n  \n def __getitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is not None :\n   return res\n  raise KeyError(key)\n  \n def __setitem__(self,key,value):\n  if not isinstance(key,str):\n   raise TypeError(\"key must be string\")\n  if not isinstance(value,str):\n   raise TypeError(\"value must be string\")\n  self.store.setItem(key,value)\n  \n  \n def __contains__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is None :\n   return False\n  return True\n  \n def __iter__(self):\n  keys=self.keys()\n  return keys.__iter__()\n  \n def get(self,key,default=None ):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  return self.store.getItem(key)or default\n  \n def pop(self,key,default=_UnProvided()):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if type(default)is _UnProvided:\n   ret=self.get(key)\n   del self[key]\n   return ret\n  else :\n   if key in self:\n    ret=self.get(key)\n    del self[key]\n    return ret\n   else :\n    return default\n    \n    \n    \n def keys(self):\n  return [self.store.key(i)for i in range(self.store.length)]\n  \n def values(self):\n  return [self.__getitem__(k)for k in self.keys()]\n  \n def items(self):\n  return list(zip(self.keys(),self.values()))\n  \n def clear(self):\n  self.store.clear()\n  \n def __len__(self):\n  return self.store.length\n  \nif has_local_storage:\n storage=LocalStorage()\n", ["browser", "sys", "browser.console", "browser.window"]], "browser": [".py", "", [], 1], "browser.ajax": [".py", "from _ajax import *\n", ["_ajax"]], "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\n\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if(_b_.isinstance(val, _b_.list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key, _b_.str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(req.charset_user_defined){\n        // on blocking mode, xhr.response is a string\n        var bytes = []\n        for(var i = 0, len = xhr.response.length; i < len; i++){\n            var cp = xhr.response.codePointAt(i)\n            if(cp > 0xf700){\n                bytes.push(cp - 0xf700)\n            }else{\n                bytes.push(cp)\n            }\n        }\n    }else if(typeof xhr.response == \"string\"){\n        if(req.mode == 'binary'){\n            return _b_.str.encode(xhr.response, req.encoding || 'utf-8')\n        }\n        return xhr.response\n    }else{\n        // else it's an ArrayBuffer\n        var buf = new Uint8Array(xhr.response),\n            bytes = Array.from(buf.values())\n    }\n    var b = _b_.bytes.$factory(bytes)\n    if(req.mode == \"binary\"){\n        return b\n    }else if(req.mode == \"document\"){\n        return $B.JSObj.$factory(xhr.response)\n    }else{\n        var encoding = req.encoding || \"utf-8\"\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction stringify(d){\n    var items = []\n    for(var entry of $B.make_js_iterator(_b_.dict.items(d))){\n        items.push(encodeURIComponent(entry[0]) + \"=\" +\n                   encodeURIComponent(entry[1]))\n    }\n    return items.join(\"&\")\n}\n\nfunction handle_kwargs(self, kw, method){\n    // kw was created with $B.obj_dict(), its keys/values are in kw.$jsobj\n    var data,\n        encoding,\n        headers={},\n        cache,\n        mode = \"text\",\n        timeout = {}\n\n    for(var key in kw.$jsobj){\n        if(key == \"data\"){\n            var params = kw.$jsobj[key]\n            if(typeof params == \"string\" || params instanceof FormData){\n                data = params\n            }else if(params.__class__ === _b_.dict){\n                for(var key of $B.make_js_iterator(_b_.dict.keys(params))){\n                    if(typeof key !== 'string'){\n                        throw _b_.ValueError.$factory(\n                            'data only supports string keys, got ' +\n                            `'${$B.class_name(key)}' object`)\n                    }\n                }\n                data = params\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(params))\n            }\n        }else if(key == \"encoding\"){\n            encoding = kw.$jsobj[key]\n        }else if(key == \"headers\"){\n            var value = kw.$jsobj[key]\n            if(! _b_.isinstance(value, _b_.dict)){\n                throw _b_.ValueError.$factory(\n                    \"headers must be a dict, not \" + $B.class_name(value))\n            }\n            for(var key of _b_.dict.$keys_string(value)){\n                headers[key.toLowerCase()] = _b_.dict.$getitem_string(value, key)\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$jsobj[key]\n            }else{\n                var f = kw.$jsobj[key]\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = kw.$jsobj[key]\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$jsobj[key]\n        }else if(key == \"cache\"){\n            cache = kw.$jsobj[key]\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n\n    return {cache, data, encoding, headers, mode, timeout}\n}\n\nvar ajax = $B.make_class('ajax')\n\najax.__repr__ = function(self){\n    return '<object Ajax>'\n}\n\najax.__getattribute__ = function(self, attr){\n    if(ajax[attr] !== undefined){\n        return function(){\n            return ajax[attr].call(null, self, ...arguments)\n        }\n    }else if(attr == \"text\"){\n        return _read(self)\n    }else if(attr == \"json\"){\n        if(self.js.responseType == \"json\"){\n            return _read(self)\n        }else{\n            var resp = _read(self)\n            try{\n                return $B.structuredclone2pyobj(JSON.parse(resp))\n            }catch(err){\n                console.log('attr json, invalid resp', resp)\n                throw err\n            }\n        }\n    }else if(self.js[attr] !== undefined){\n        if(typeof self.js[attr] == \"function\"){\n            return function(){\n                if(attr == \"setRequestHeader\"){\n                    ajax.set_header.call(null, self, ...arguments)\n                }else{\n                    if(attr == 'overrideMimeType'){\n                        console.log('override mime type')\n                        self.hasMimeType = true\n                    }\n                    return self.js[attr](...arguments)\n                }\n            }\n        }else{\n            return self.js[attr]\n        }\n    }else if(attr == \"xml\"){\n        return $B.JSObj.$factory(self.js.responseXML)\n    }\n}\n\najax.bind = function(self, evt, func){\n    // req.bind(evt,func) is the same as req.onevt = func\n    self.js['on' + evt] = function(){\n        try{\n            return func.apply(null, arguments)\n        }catch(err){\n            $B.handle_error(err)\n        }\n    }\n    return _b_.None\n}\n\najax.open = function(){\n    var $ = $B.args('open', 4,\n            {self: null, method: null, url: null, async: null},\n            ['self', 'method', 'url', 'async'], arguments,\n            {async: true}, null, null),\n        self = $.self,\n        method = $.method,\n        url = $.url,\n        async = $.async\n    if(typeof method !== \"string\"){\n        throw _b_.TypeError.$factory(\n            'open() argument method should be string, got ' +\n            $B.class_name(method))\n    }\n    if(typeof url !== \"string\"){\n        throw _b_.TypeError.$factory(\n            'open() argument url should be string, got ' +\n            $B.class_name(url))\n    }\n    self.$method = method\n    self.blocking = ! self.async\n    self.js.open(method, url, async)\n}\n\najax.read = function(self){\n    return _read(self)\n}\n\najax.send = function(self, params){\n    // params can be Python dictionary or string\n    var content_type\n    for(var key in self.headers){\n        var value = self.headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n    if((self.encoding || self.blocking) && ! self.hasMimeType){\n        // On blocking mode, or if an encoding has been specified,\n        // override Mime type so that bytes are not processed\n        // (unless the Mime type has been explicitely set)\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        self.charset_user_defined = true\n    }\n    var res = ''\n    if(! params){\n        self.js.send()\n        return _b_.None\n    }\n    if(_b_.isinstance(params, _b_.str)){\n        res = params\n    }else if(_b_.isinstance(params, _b_.dict)){\n        if(content_type == 'multipart/form-data'){\n            // The FormData object serializes the data in the 'multipart/form-data'\n            // content-type so we may as well override that header if it was set\n            // by the user.\n            res = new FormData()\n            var items = _b_.list.$factory(_b_.dict.items(params))\n            for(var i = 0, len = items.length; i < len; i++){\n                add_to_res(res, _b_.str.$factory(items[i][0]), items[i][1])\n            }\n        }else{\n            if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                    ! content_type){\n                // Set default Content-Type for POST requests\n                self.js.setRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded\")\n            }\n            var items = _b_.list.$factory(_b_.dict.items(params))\n            for(var i = 0, len = items.length; i < len; i++){\n                var key = encodeURIComponent(_b_.str.$factory(items[i][0]));\n                if(_b_.isinstance(items[i][1], _b_.list)){\n                    for (j = 0; j < items[i][1].length; j++) {\n                        res += key +'=' +\n                            encodeURIComponent(_b_.str.$factory(items[i][1][j])) + '&'\n                    }\n                }else{\n                    res += key + '=' +\n                        encodeURIComponent(_b_.str.$factory(items[i][1])) + '&'\n                }\n            }\n            res = res.substr(0, res.length - 1)\n        }\n    }else if(params instanceof FormData){\n        res = params\n    }else{\n        throw _b_.TypeError.$factory(\n            \"send() argument must be string or dictionary, not '\" +\n            _b_.str.$factory(params.__class__) + \"'\")\n    }\n    self.js.send(res)\n    return _b_.None\n}\n\najax.set_header = function(self, key, value){\n    self.headers[key.toLowerCase()] = value\n}\n\najax.set_timeout = function(self, seconds, func){\n    self.js.$requestTimer = setTimeout(\n        function() {\n            self.js.abort()\n            func()\n        },\n        seconds * 1000)\n}\n\najax.$factory = function(){\n\n    if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest()\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){\n            this.onuninitialized(res)\n        }else if(state == 1 && this.onloading){\n            this.onloading(res)\n        }else if(state == 2 && this.onloaded){\n            this.onloaded(res)\n        }else if(state == 3 && this.oninteractive){\n            this.oninteractive(res)\n        }else if(state == 4 && this.oncomplete){\n            if(timer !== null){\n                window.clearTimeout(timer)\n            }\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n    var self = ajax.$factory()\n    self.blocking = $.blocking\n    var items = handle_kwargs(self, kw, method),\n        mode = self.mode = items.mode,\n        encoding = self.encoding = items.encoding\n        qs = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    self.js.open(method.toUpperCase(), url, async)\n\n    if(async){\n        if(mode == \"json\" || mode == \"document\"){\n            self.js.responseType = mode\n        }else{\n            self.js.responseType = \"arraybuffer\"\n            if(mode != \"text\" && mode != \"binary\"){\n                throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n            }\n        }\n    }else{\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        self.charset_user_defined = true\n    }\n    for(var key in items.headers){\n        self.js.setRequestHeader(key, items.headers[key])\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n        method = $.method,\n        url = $.url,\n        async = !$.blocking,\n        kw = $.kw,\n        content_type\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        timeout = items.timeout\n    if(_b_.isinstance(data, _b_.dict)){\n        data = stringify(data)\n    }\n\n    set_timeout(self, timeout)\n    for(var key in items.headers){\n        var value = items.headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n    if(method.toUpperCase() == 'POST' && !content_type){\n        // set default Content-Type for POST requests\n        self.js.setRequestHeader('Content-Type',\n            'application/x-www-form-urlencoded')\n    }\n\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction form_data(form){\n    var missing = {},\n        $ = $B.args('form_data', 1, {form: null}, ['form'], arguments,\n            {form: missing}, null, null)\n    if($.form === missing){\n        return new FormData()\n    }else{\n        return new FormData($.form)\n    }\n}\n\nfunction connect(){\n    _request_without_body.call(null, \"connect\", ...arguments)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction patch(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction trace(){\n    _request_without_body.call(null, \"trace\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory(),\n        method = 'POST',\n        field_name = 'filetosave'\n\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        headers = items.headers,\n        timeout = items.timeout\n\n    for(var key in items.headers){\n        var value = items.headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n    set_timeout(self, timeout)\n\n    if(kw.$jsobj.hasOwnProperty('method')){\n        method = kw.$jsobj.method\n    }\n\n    if(kw.$jsobj.hasOwnProperty('field_name')){\n        field_name = kw.$jsobj.field_name\n    }\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    if(items.data){\n        if(items.data instanceof FormData){\n            // append additional data\n            for(var d of items.data){\n                formdata.append(d[0], d[1])\n            }\n        }else if(_b_.isinstance(items.data, _b_.dict)){\n            for(var d of _b_.list.$factory(_b_.dict.items(items.data))){\n                formdata.append(d[0], d[1])\n            }\n        }else{\n            throw _b_.ValueError.$factory(\n                'data value must be a dict of form_data')\n        }\n    }\n\n    self.js.open(method, url, _b_.True)\n    self.js.send(formdata)\n\n    for(var key in kw.$jsobj){\n        if(key.startsWith(\"on\")){\n            ajax.bind(self, key.substr(2), kw.$jsobj[key])\n        }\n    }\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    delete: _delete,\n    file_upload: file_upload,\n    connect,\n    form_data,\n    get,\n    head,\n    options,\n    patch,\n    post,\n    put,\n    trace\n}\n\n})(__BRYTHON__)\n"], "sys": [".py", "\nfrom _sys import *\n\nimport browser\nimport javascript\n\nclass Error(Exception):\n pass\n \n_getframe=Getframe\n\nabiflags=0\n\ndef audit(event,*args):\n ''\n pass\n \nbrython_debug_mode=__BRYTHON__.debug\n\nbase_exec_prefix=__BRYTHON__.brython_path\n\nbase_prefix=__BRYTHON__.brython_path\n\nbuiltin_module_names=__BRYTHON__.builtin_module_names\n\nbyteorder='little'\n\ndont_write_bytecode=True\n\nexec_prefix=__BRYTHON__.brython_path\n\nexecutable=__BRYTHON__.brython_path+'brython.js'\n\nargv=orig_argv=[__BRYTHON__.script_path]\n\ndef displayhook(value):\n if value is not None :\n  stdout.write(repr(value))\n  \n__displayhook__=displayhook\n\ndef exit(i=None ):\n raise SystemExit('')\n \nclass flag_class:\n\n def __init__(self):\n  self.debug=0\n  self.inspect=0\n  self.interactive=0\n  self.optimize=0\n  self.dont_write_bytecode=0\n  self.no_user_site=0\n  self.no_site=0\n  self.ignore_environment=0\n  self.verbose=0\n  self.bytes_warning=0\n  self.quiet=0\n  self.hash_randomization=1\n  self.isolated=0\n  self.dev_mode=False\n  self.utf8_mode=0\n  self.warn_default_encoding=0\n  \nflags=flag_class()\n\ndef getfilesystemencoding(*args,**kw):\n ''\n\n \n return 'utf-8'\n \ndef getfilesystemencodeerrors():\n return \"utf-8\"\n \ndef intern(string):\n return string\n \nclass int_info:\n bits_per_digit=30\n sizeof_digit=4\n default_max_str_digits=__BRYTHON__.int_max_str_digits\n str_digits_check_threshold=__BRYTHON__.str_digits_check_threshold\n \ndef get_int_max_str_digits():\n return __BRYTHON__.int_max_str_digits\n \ndef set_int_max_str_digits(value):\n try :\n  value=int(value)\n except :\n  raise ValueError(f\"'{value.__class__.__name__}' object \"\n  \"cannot be interpreted as an integer\")\n if value !=0 and value <int_info.str_digits_check_threshold:\n  raise ValueError('maxdigits must be 0 or larger than 640')\n __BRYTHON__.int_max_str_digits=value\n \n \nmaxsize=__BRYTHON__.max_array_size\n\nmaxunicode=1114111\n\nplatform=\"brython\"\n\nplatlibdir=__BRYTHON__.brython_path+'Lib'\n\nprefix=__BRYTHON__.brython_path\n\nstdlib_module_names=frozenset(__BRYTHON__.stdlib_module_names)\n\nversion='.'.join(str(x)for x in __BRYTHON__.version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"\\\n%__BRYTHON__.compiled_date\nhexversion=0x030800f0\n\nclass _version_info:\n\n def __init__(self,version_info):\n  self.version_info=version_info\n  self.major=version_info[0]\n  self.minor=version_info[1]\n  self.micro=version_info[2]\n  self.releaselevel=version_info[3]\n  self.serial=version_info[4]\n  \n def __getitem__(self,index):\n  if isinstance(self.version_info[index],list):\n   return tuple(self.version_info[index])\n  return self.version_info[index]\n  \n def hexversion(self):\n  try :\n   return '0%d0%d0%d'%(self.major,self.minor,self.micro)\n  finally :\n   return '0%d0000'%(self.major)\n   \n def __str__(self):\n  _s=\"sys.version(major=%d, minor=%d, micro=%d, releaselevel='%s', \"\\\n  \"serial=%d)\"\n  return _s %(self.major,self.minor,self.micro,\n  self.releaselevel,self.serial)\n  \n __repr__=__str__\n \n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)==other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __le__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)!=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n  \n  \nversion_info=_version_info(__BRYTHON__.version_info)\n\nclass SimpleNamespace:\n\n def __init__(self,/,**kwargs):\n  self.__dict__.update(kwargs)\n  \n def __repr__(self):\n  items=(f\"{k}={v!r}\"for k,v in self.__dict__.items())\n  return \"{}({})\".format(\"namespace\",\", \".join(items))\n  \n def __eq__(self,other):\n  if isinstance(self,SimpleNamespace)and isinstance(other,SimpleNamespace):\n   return self.__dict__ ==other.__dict__\n  return NotImplemented\n  \nSimpleNamespace.__module__=\"types\"\n\nvi=_version_info(__BRYTHON__.implementation)\nimplementation=SimpleNamespace(name=\"brython\",\nversion=vi,\nhexversion=vi.hexversion(),\ncache_tag=None )\n\nclass _hash_info:\n\n def __init__(self):\n  self.width=32\n  self.modulus=2147483647\n  self.inf=314159\n  self.nan=0\n  self.imag=1000003\n  self.algorithm='siphash24'\n  self.hash_bits=64\n  self.seed_bits=128\n  cutoff=0\n  \n def __repr__(self):\n \n  return \"sys.hash_info(width=32, modulus=2147483647, inf=314159, \"\\\n  \"nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, \"\\\n  \"seed_bits=128, cutoff=0)\"\n  \nhash_info=_hash_info()\n\nclass _float_info:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self):\n  self.dig=15\n  self.epsilon=2 **-52\n  self.mant_dig=53\n  self.max=__BRYTHON__.MAX_VALUE\n  self.max_exp=2 **10\n  self.max_10_exp=308\n  self.min=__BRYTHON__.MIN_VALUE\n  self.min_exp=-1021\n  self.min_10_exp=-307\n  self.radix=2\n  self.rounds=1\n  self._tuple=(self.max,self.max_exp,self.max_10_exp,self.min,\n  self.min_exp,self.min_10_exp,self.dig,self.mant_dig,self.epsilon,\n  self.radix,self.rounds)\n  \n def __getitem__(self,k):\n  return self._tuple[k]\n  \n def __iter__(self):\n  return iter(self._tuple)\n  \nfloat_info=_float_info()\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return 'utf-8'\n \n \n__stdout__=stdout\n__stderr__=stderr\n__stdin__=stdin\n\n__excepthook__=excepthook\n", ["browser", "_sys", "javascript"]]}
__BRYTHON__.update_VFS(scripts)